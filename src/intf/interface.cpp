// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.


#include "Logger.h"
#include "event.h"
#include "events_def.h"
#include "interface.h"

#include <functional>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include "channel.h"

#include "protocol_head.h"
#include "events_def.h"
#include "protocol_codec.h"
#include "process.h"


#define BUF_SIZE   1024
#define MAX_EVENTS 64
extern brks_process_t brks_processes[BRKS_MAX_PROCESS_NUM];


Interface::Interface(std::function< iEvent* (const iEvent*)>  callback) : callback_(callback)
{
    codecs_[JSON_PROTOCOL_TYPE]   = new json_protocol_codec_t;
    codecs_[PB_PROTOCOL_TYPE]     = NULL;
    codecs_[FB_PROTOCOL_TYPE]     = NULL;
    codecs_[BINARY_PROTOCOL_TYPE] = NULL;

    epoll_fd_ = epoll_create(1);
    if (epoll_fd_ == -1)
    {
        LOG_ERROR("cannot create epoll_fd_!\n");
    }
};

bool Interface::add_epoll_event(int efd, int socket, int events)
{
    struct epoll_event event;

    event.events  = events;//EPOLLIN | EPOLLOUT | EPOLLET;
    event.data.fd = socket;
    int ret = epoll_ctl(efd, EPOLL_CTL_ADD, socket, &event);
    if (ret == -1)
    {
        LOG_ERROR("can not add event to epoll_fd_!\n");
        return false;
    }

    return true;
}

bool Interface::accept_client(int efd, int sfd)
{
    struct sockaddr client_addr;
    int addrlen = sizeof(struct sockaddr);

    int client_fd = accept(sfd, &client_addr, &addrlen);
    if (client_fd == -1)
    {
       if (errno == EAGAIN || errno == EWOULDBLOCK)
       {
           return true;
       }
       else
       {
           LOG_ERROR("cannot accept new server_socket!\n");
           return false;
       }
    }

    int ret = set_socket_non_block(client_fd);
    if (ret == -1)
    {
        LOG_ERROR("cannot set flags!\n");
    }

    if (!add_epoll_event(efd, client_fd, EPOLLET | EPOLLIN))
    {
        return false;
    }

    return true;
}

bool Interface::add_channel_socket(brks_socket_t *fd)
{
    channel_fd_[0] = fd[0];
    channel_fd_[1] = fd[1];

    if (!add_epoll_event(epoll_fd_, channel_fd_[1], EPOLLET | EPOLLIN))
    {
        return false;
    }

    return true;
}

bool Interface::add_server_socket(brks_socket_t socket)
{
    int ret = listen(socket, SOMAXCONN);
    if (ret == -1)
    {
        LOG_ERROR("cannot listen at the given server_socket!\n");
        return false;
    }
    else
    {
        LOG_INFO("process %d listend on 9090 port success.", getpid());
    }

    /* just only add to server_sockets_, when recived BRKS_CMD_SERVICE command
     * add every socket to epoll
     */
    server_sockets_.push_back(socket);

    return true;
}

void Interface::run()
{
    struct epoll_event events[MAX_EVENTS] = {0};

    while (1)
    {
        int cnt = epoll_wait(epoll_fd_, events, MAX_EVENTS, -1);

        for (int i = 0; i < cnt; i++)
        {
            if ((events[i].events & EPOLLERR) || (events[i].events & EPOLLHUP)
                || !(events[i].events & EPOLLIN))
            {
                LOG_ERROR("server_socket fd error!\n");
                ::close(events[i].data.fd);
                continue;

            }
            else if ((events[i].data.fd == server_sockets_[0])
                || (events[i].data.fd == server_sockets_[1]) )
            {
                accept_client(epoll_fd_, events[i].data.fd);
            }
            else if (events[i].data.fd == channel_fd_[1])
            {
                // TODO : handle all the channel events
                brks_channel_t ch;
                memset(&ch, 0, sizeof(ch));
                brks_read_channel(events[i].data.fd, &ch, CHANNEL_WITHOUT_SPECIAl_SIZE);
                handle_channel_event(&ch);
            }
            else
            {
                char buf[BUF_SIZE] = {0};
                int result = 1;
                int cnt = nio_recv(events[i].data.fd, buf, sizeof(protocol_head_t), &result);
                if (result <= 0) continue;

                //decode head
                protocol_head_t proto_head;
                protocol_head_codec_t head_codec;
                head_codec.decode(buf, BUF_SIZE, &proto_head);

                result = 1;
                cnt = nio_recv(events[i].data.fd, buf + sizeof(protocol_head_t), proto_head.len_, &result);
                if (result <= 0) continue;

                if ((proto_head.type_ >= JSON_PROTOCOL_TYPE)
                    && (proto_head.type_ <= BINARY_PROTOCOL_TYPE)
                    && (codecs_[proto_head.type_] != NULL))
                {
                    iEvent* ev  = codecs_[proto_head.type_]->decode(proto_head.msg_id_, buf + sizeof(protocol_head_t), proto_head.len_);
                    iEvent* rsp = callback_(ev);

                    // TODO : encode rsp event to
                    // TODO : send response,
                    // nio_write

                }
                else
                {
                    LOG_ERROR("message (sn=%ld) type %d is error.", proto_head.msg_sn, proto_head.type_);
                }
            }
        }
    }

    return;
}

bool Interface::close()
{

    return true;
}

bool Interface::handle_channel_event(brks_channel_t* ch)
{
    bool ret = true;

    switch(ch->command)
    {
    case BRKS_CMD_OPEN_CHANNEL:
        brks_processes[ch->slot].pid = ch->pid;
        brks_processes[ch->slot].channel[0] = ch->fd;
        break;
    case BRKS_CMD_CLOSE_CHANNEL:
        break;
    case BRKS_CMD_SERVICE:
        for (i32 i = 0; i < server_sockets_.size(); i ++)
        {
            if (!add_epoll_event(epoll_fd_, server_sockets_[i], EPOLLIN))
            {
                ret = false;
                LOG_ERROR("add socket %d to epoll failed.", server_sockets_[i]);
            }
        }
        break;
    case BRKS_CMD_MOVEFD:
        if (!add_epoll_event(epoll_fd_, ch->fd, EPOLLIN))
        {
            ret = false;
            LOG_ERROR("add socket %d to epoll failed.", ch->fd);
        }
        else
        {
            ;
        }
        break;
    case BRKS_CMD_QUIT:
        /*
         * how to graceful quit,
         */
        break;
    }

    return true;
}


